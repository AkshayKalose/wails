# Enums

In Go, an enum (enumeration) is a user-defined type that consists of a set of named constants called enumerators. Enums 
are useful for representing a fixed set of values that a variable can take.

To define an enum in Go, you can use a type declaration with a list of constant values. Here's an example:

```go
type Title string

const (
    Mr  Title = "Mr"
    Mrs Title = "Mrs"
    Ms  Title = "Ms"
)
```

In this example, we define an enum type called `Title` using the `type` keyword. We then declare a set of constants 
(`Mr`, `Mrs`, `Ms`) of type `Title` using the `const` keyword.

## Using Enums in Bound Structs

Let's extend our previous example to use the `Title` enum in the `Person` struct:

```go
package main

import (
    "github.com/wailsapp/wails/v3/pkg/application"
    "log"
)

// Title is a title
type Title string

const (
    Mr  Title = "Mr"
    Mrs Title = "Mrs"
    Ms  Title = "Ms"
)

// Person is a person
type Person struct {
    // Name of the person
    Name  string
    // Title of the person
    Title Title
}

type GreetService struct{}

func (g *GreetService) Greet(person Person) string {
    return "Hello " + string(person.Title) + " " + person.Name
}

func main() {
    app := application.New(application.Options{
        Bind: []any{
            &GreetService{},
        },
    })
    // ....
    app.NewWebviewWindow()
    err := app.Run()
    if err != nil {
        log.Fatal(err)
    }
}
```

In this updated example, we add a `Title` field of type `Title` to the `Person` struct. The `Greet` method now includes the `Title` in the greeting message.

When we run the bindings generator, it will process the enum and generate the corresponding JavaScript or TypeScript code.

## Generating Bindings with Enums

After adding the `Title` enum to our example, let's generate the bindings using the following command:

```bash
% wails3 generate bindings
```

The output should display information about the processed package, struct, method, enum, and model:

```bash
INFO Processed: 1 Package, 1 Struct, 1 Method, 1 Enum, 1 Model in 1.044166ms.
INFO Output directory: /Users/lea/GolandProjects/tempdocs/binding/frontend/bindings
```

If we look in the `frontend/bindings` directory, we should see a generated `models.js` file that includes the enum definition:

```javascript
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

/**
 * @readonly
 * @enum {string}
 */
export const Title = {
    Mr: "Mr",
    Mrs: "Mrs",
    Ms: "Ms",
};

/**
 * Person defines a person
 */
export class Person {
    /**
     * Creates a new Person instance.
     * @param {Partial<Person>} [source = {}] - The source object to create the Person.
     */
    constructor(source = {}) {
        if (!("Name" in source)) {
            /**
             * Name of the person
             * @member
             * @type {string}
             */
            this["Name"] = "";
        }
        if (!("Title" in source)) {
            /**
             * Title of the person
             * @member
             * @type {Title}
             */
            this["Title"] = null;
        }
        Object.assign(this, source);
    }

    /**
     * Creates a new Person instance from a string or object.
     * @param {string|object} source - The source data to create a Person instance from.
     * @returns {Person} A new Person instance.
     */
    static createFrom(source) {
        let parsedSource = typeof source === 'string' ? JSON.parse(source) : source;
        return new Person(parsedSource);
    }
}
```

The generated `models.js` file includes the `Title` enum definition, which is exported as a read-only object with the enum values as properties. The `Person` class also includes a `Title` property of type `Title`.

You can now use the generated enum and class in your frontend code when interacting with the bound `GreetService` struct.
