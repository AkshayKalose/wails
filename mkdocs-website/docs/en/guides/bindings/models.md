# Binding Models

In addition to binding methods, you can also use structs as input or output parameters in your bound methods. When structs are used as parameters, Wails generates corresponding JavaScript versions of those types.

Let's extend the previous example to use a `Person` type that has a `Name` field:

```go title="main.go"
package main

import (
	"github.com/wailsapp/wails/v3/pkg/application"
	"log"
)

// Person defines a person
type Person struct {
	// Name of the person
	Name string
}

type GreetService struct{}

func (g *GreetService) Greet(person Person) string {
	return "Hello " + person.Name
}

func main() {
	app := application.New(application.Options{
		Bind: []any{
			&GreetService{},
		},
	})
	// ....
	app.NewWebviewWindow()
	err := app.Run()
	if err != nil {
		log.Fatal(err)
	}
}

```

In this updated example, we define a `Person` struct with a `Name` field. The `Greet` method in the `GreetService` struct
now takes a `Person` as an input parameter.

When you run the bindings generator, Wails will generate a corresponding JavaScript `Person` type that mirrors the Go
struct. This allows you to create instances of the `Person` type in your frontend code and pass them to the bound
`Greet` method.

If we run the bindings generator again, we should see the following output:

```bash
% wails3 generate bindings
 INFO  Processed: 1 Package, 1 Struct, 1 Method, 0 Enums, 1 Models in 4.075625ms.
 INFO  Output directory: /Users/me/myproject/frontend/bindings
```

In the `frontend/bindings/main` directory, you should see a new `models.js` file containing the following code:

```javascript title="models.js"
// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

/**
 * Person defines a person
 */
export class Person {
    /**
     * Creates a new Person instance.
     * @param {Partial<Person>} [source = {}] - The source object to create the Person.
     */
    constructor(source = {}) {
        if (!("Name" in source)) {
            /**
             * Name of the person
             * @member
             * @type {string}
             */
            this["Name"] = "";
        }

        Object.assign(this, source);
    }

    /**
     * Creates a new Person instance from a string or object.
     * @param {string|object} source - The source data to create a Person instance from.
     * @returns {Person} A new Person instance.
     */
    static createFrom(source) {
        let parsedSource = typeof source === 'string' ? JSON.parse(source) : source;
        return new Person(parsedSource);
    }
};

```

The `Person` class is generated with a constructor that takes an optional `source` parameter, which allows you to
create a new `Person` instance from an object. It also has a static `createFrom` method that can create a `Person`
instance from a string or object.

You may also notice that comments in the Go struct are kept in the generated JavaScript code! This can be helpful for
understanding the purpose of the fields and methods in the generated models and should be picked up by your IDE.

## Using Bound Models

Here's an example of how you can use the generated JavaScript `Person` type in your frontend code:

```javascript title="main.js"
import {Greet} from "./bindings/main/GreetService.js";
import {Person} from "./bindings/main/models.js";

const resultElement = document.getElementById('result');

async function doGreet() {
    let person = new Person({Name: document.getElementById('name').value});
    if (!person.Name) {
        person.Name = 'anonymous';
    }
    resultElement.innerText = await Greet(person);
}
```

In this example, we import the generated `Person` type from the `models` module. We create a new instance of `Person`,
set its `Name` property, and pass it to the `Greet` method.

Using bound models allows you to work with complex data structures and seamlessly pass them between the frontend and
backend of your Wails application.
